/**
 
 * - Ensures accounts: test.near (MASTER), ft.test.near (FT contract), user.test.near (receiver)
 * - Deploys fungible_token.wasm to ft.test.near
 * - Initializes contract with new_default_meta (owner = test.near)
 * - Registers storage for owner and receiver
 *
 * Required env:
 *   - NODE_URL (default http://127.0.0.1:3030)
 *   - MASTER_ACCOUNT (default test.near)
 *   - MASTER_ACCOUNT_PRIVATE_KEY (ed25519:...)
 *   - FT_CONTRACT (default ft.test.near)
 *   - RECEIVER_ID (default user.test.near)
 */
import { connect, keyStores, KeyPair, utils } from 'near-api-js';
import fs from 'fs';
import { fileURLToPath } from 'url';
import path from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function normalizeKey(pk) {
  let s = String(pk || '').trim();
  if ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))) {
    s = s.slice(1, -1);
  }
  if (!s.startsWith('ed25519:') && !s.startsWith('secp256k1:')) {
    s = `ed25519:${s}`;
  }
  const idx = s.indexOf(':');
  if (idx === -1) return s;
  const curve = s.slice(0, idx);
  let body = s.slice(idx + 1).replace(/\s+/g, '');
  return `${curve}:${body}`;
}

function getSandboxKey(masterAccountId) {
  try {
    const home = process.env.HOME || '';
    const nearHome = process.env.NEAR_HOME || (home ? path.join(home, '.near') : '');
    const candidates = [
      nearHome ? path.join(nearHome, 'validator_key.json') : '',
      nearHome ? path.join(nearHome, 'data', 'validator_key.json') : '',
      nearHome ? path.join(nearHome, 'node', 'validator_key.json') : '',
      nearHome ? path.join(nearHome, 'node0', 'validator_key.json') : '',
      home ? path.join(home, '.near', 'validator_key.json') : '',
      home ? path.join(home, '.near', 'data', 'validator_key.json') : '',
      home ? path.join(home, '.near', 'node', 'validator_key.json') : '',
      home ? path.join(home, '.near', 'node0', 'validator_key.json') : '',
      home ? path.join(home, '.near', 'sandbox', 'validator_key.json') : '',
    ].filter(Boolean);

    console.log('🔎 getSandboxKey() candidates:', JSON.stringify(candidates, null, 2));

    for (const p of candidates) {
      if (p && fs.existsSync(p)) {
        try {
          const raw = fs.readFileSync(p, 'utf-8');
          const data = JSON.parse(raw);
          const key = data.secret_key || data.private_key || null;
          const accountId = data.account_id || null;
          if (key && accountId === masterAccountId) {
            console.log(`✅ Found matching validator key at: ${p} for account: ${accountId}`);
            return { key, path: p, accountId };
          } else if (key) {
            console.log(`⚠️  Found validator key at: ${p} but account mismatch (expected: ${masterAccountId}, found: ${accountId})`);
          }
        } catch (e) {
          console.warn(`⚠️  Failed reading key at ${p}:`, e?.message || e);
        }
      }
    }
    console.warn('⚠️  No matching validator_key.json found for account:', masterAccountId);
    return null;
  } catch (e) {
    console.warn('⚠️  getSandboxKey() error:', e?.message || e);
    return null;
  }
}

function resolveWasmPath() {
  const candidates = [
    // Primary: ft-claiming-service/fungible_token.wasm (../ from ci/)
    path.resolve(__dirname, '..', 'fungible_token.wasm'),
    // Fallback: repoRoot/fungible_token.wasm (../../ from ci/ if project checked out differently)
    path.resolve(__dirname, '..', '..', 'fungible_token.wasm'),
    // Additional: res/fungible_token.wasm
    path.resolve(__dirname, '..', 'res', 'fungible_token.wasm'),
    path.resolve(__dirname, '..', '..', 'res', 'fungible_token.wasm')
  ];

  for (const p of candidates) {
    if (fs.existsSync(p)) return p;
  }

  throw new Error(`fungible_token.wasm not found. Tried:\n - ${candidates.join('\n - ')}`);
}

async function main() {
  const nodeUrl = process.env.NODE_URL || 'http://127.0.0.1:3030';
  const networkId = 'sandbox';
  const masterAccountId = process.env.MASTER_ACCOUNT || 'test.near';
  const ftContractId = process.env.FT_CONTRACT || 'ft.test.near';
  // Default receiver to master to avoid subaccount creation on CI runners
  const userAccountId = process.env.RECEIVER_ID || masterAccountId;

  // Prefer sandbox validator key (freshly generated by near-sandbox) over ENV
  const sandbox = getSandboxKey(masterAccountId);
  const sandboxKey = sandbox?.key;
  const envKey = process.env.MASTER_ACCOUNT_PRIVATE_KEY;
  const chosen = sandboxKey || envKey;

  if (!chosen) {
    throw new Error('MASTER_ACCOUNT_PRIVATE_KEY is required (env or sandbox validator_key.json)');
  }
  const normalizedKey = normalizeKey(chosen);

  // No near-cli: we deploy using near-api-js v2 only (most stable for sandbox)

  console.log('Deploying to sandbox RPC with params:');
  console.log({ nodeUrl, networkId, masterAccountId, ftContractId, userAccountId });

  const keyStore = new keyStores.InMemoryKeyStore();
  const masterKeyPair = KeyPair.fromString(normalizedKey);

  // Defensive: set key for a few common network namespaces to avoid signer namespace mismatch
  const namespaces = [networkId, 'local', 'default'];
  for (const ns of namespaces) {
    await keyStore.setKey(ns, masterAccountId, masterKeyPair);
    await keyStore.setKey(ns, ftContractId, masterKeyPair);
    await keyStore.setKey(ns, userAccountId, masterKeyPair);
  }

  // Preflight: ensure key is actually retrievable for the active namespace
  const checkKey = await keyStore.getKey(networkId, masterAccountId);
  console.log('Preflight key check:', {
    hasKeyForNamespace: !!checkKey,
    namespace: networkId,
    publicKey: checkKey ? checkKey.getPublicKey().toString() : null
  });

  const near = await connect({ networkId, nodeUrl, deps: { keyStore } });
  // Use official helper to construct Account to ensure internal fields are ready
  const master = await near.account(masterAccountId);
  console.log('Master accountId check:', master.accountId);

  async function accountExists(accountId) {
    try {
      const acc = await near.account(accountId);
      await acc.state();
      return true;
    } catch {
      return false;
    }
  }

  async function createAccountIfMissing(parent, newAccountId, amountYocto) {
    if (await accountExists(newAccountId)) {
      console.log(`Account exists: ${newAccountId}`);
      return;
    }
    const pk = masterKeyPair.getPublicKey();
    console.log(`Creating account ${newAccountId} with initial balance ${amountYocto} yocto`);
    await parent.createAccount(newAccountId, pk, amountYocto);
  }

  // Ensure accounts with initial balance
  const initialBalance = utils.format.parseNearAmount('100');

  // If FT_CONTRACT is the same as MASTER_ACCOUNT (test.near), skip creating subaccount to avoid signerId issues
  if (ftContractId !== masterAccountId) {
    await createAccountIfMissing(master, ftContractId, initialBalance);
  } else {
    console.log('Using master account as FT contract account; skipping ft.test.near creation');
  }

  // If RECEIVER_ID equals MASTER, no need to create separate user account
  if (userAccountId !== masterAccountId) {
    await createAccountIfMissing(master, userAccountId, initialBalance);
  } else {
    console.log('Receiver equals master; skipping user account creation');
  }

  // Deploy FT wasm using near CLI when possible (most robust against borsh/schema issues).
  // Fallback to near-api-js v2 deployContract if no keyPath is available.
  const ft = (ftContractId === masterAccountId)
    ? master
    : await near.account(ftContractId);
  const wasmPath = resolveWasmPath();
  console.log(`Deploying WASM from: ${wasmPath}`);
  const wasm = fs.readFileSync(wasmPath);
  await ft.deployContract(wasm);

  // Initialize FT contract
  console.log('Initializing FT contract (new_default_meta)...');
  try {
    await ft.functionCall({
      contractId: ftContractId,
      methodName: 'new_default_meta',
      args: {
        owner_id: masterAccountId,
        total_supply: '1000000000000000000000000000000'
      },
      gas: '30000000000000'
    });
  } catch (e) {
    console.warn('new_default_meta may have already been called or failed non-fatally:', e?.message || e);
  }

  // Storage deposits for master and receiver
  const storageDeposit = utils.format.parseNearAmount('0.00125');
  for (const aid of [masterAccountId, userAccountId]) {
    console.log(`Registering storage for ${aid} ...`);
    try {
      await ft.functionCall({
        contractId: ftContractId,
        methodName: 'storage_deposit',
        args: { account_id: aid, registration_only: true },
        gas: '30000000000000',
        attachedDeposit: storageDeposit
      });
    } catch (e) {
      console.warn(`storage_deposit for ${aid} may already exist or failed non-fatally:`, e?.message || e);
    }
  }

  console.log('✅ FT deployed and initialized on sandbox RPC');
  console.log(`   - Contract: ${ftContractId}`);
  console.log(`   - Owner:    ${masterAccountId}`);
  console.log(`   - Receiver: ${userAccountId}`);
}

main().catch((err) => {
  console.error('❌ Deployment failed:', err);
  process.exit(1);
});